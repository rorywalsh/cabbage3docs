"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1573],{7372:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(4848),s=t(8453);const o={},i=void 0,l={id:"cabbage_widgets/properties/channelGentable",title:"channelGentable",description:"",source:"@site/docs/cabbage_widgets/properties/channelGentable.mdx",sourceDirName:"cabbage_widgets/properties",slug:"/cabbage_widgets/properties/channelGentable",permalink:"/cabbage3docs/docs/cabbage_widgets/properties/channelGentable",draft:!1,unlisted:!1,editUrl:"https://github.com/rorywalsh/cabbage3docs/tree/main/docs/cabbage_widgets/properties/channelGentable.mdx",tags:[],version:"current",frontMatter:{}},r={},c=[];function h(e){const n={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-plaintext",children:'```json\n## `channel()`\n\n`channel()` is used to define the channels for selectable region output on the genTable widget. It accepts an object with properties for start position and length:\n\n```javascript\nchannel({ start: "channelName1", length: "channelName2" })\n```\n\n- **start**: Channel that receives the starting sample position of the selected region (integer)\n- **length**: Channel that receives the length of the selected region in samples (integer)\n\nWhen a user selects a region on the genTable, the widget sends the start position and length to the specified channels as sample indices. These can be directly used in Csound to access the corresponding portion of the function table.\n\n### Example Usage\n\n```javascript\ngentable({\n    bounds: {left: 10, top: 10, width: 600, height: 200},\n    channel: {start: "region_start", length: "region_length"},\n    tableNumber: 1,\n    selectableRegions: true\n})\n```\n\nIn your Csound code:\n\n```csound\nkRegionStart cabbageGetValue "region_start"\nkRegionLength cabbageGetValue "region_length"\n\n; Use the sample positions directly\nkSample = 0\nwhile kSample < kRegionLength do\n    kValue table kRegionStart + kSample, giTable1\n    ; Process the sample...\n    kSample += 1\nod\n```\n```\nDefines the channel configuration for the genTable widget:\n- **id**: Unique identifier for the genTable widget itself. Use this channel with `cabbageSet` to update any of the genTable\'s attributes.\n- **start**: Channel name for the selection start position (normalized 0-1). This channel is updated when the user selects a region on the waveform (only when `selectableRegions` is enabled)\n- **length**: Channel name for the selection length (normalized 0-1). This channel is updated when the user selects a region on the waveform (only when `selectableRegions` is enabled)\n\nThe start and length channels are only used when `selectableRegions` is enabled. Values are normalized (0-1) representing positions within the visible range of the table, regardless of the actual sample count. You can read these values in your Csound code using `cabbageGetValue` and convert them to sample positions using the table size.\n\n**Example usage in Csound:**\n```csound\nkRegionStart cabbageGetValue "region_start"\nkRegionLength cabbageGetValue "region_length"\nkTableSize = ftlen(giTable1)\nkStartSample = kRegionStart * kTableSize\nkLengthSamples = kRegionLength * kTableSize\n; Process the selected region...\n```\n\n'})})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(6540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);