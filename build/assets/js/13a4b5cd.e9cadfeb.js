"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2458],{3237:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>b,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=a(4848),n=a(8453);const o={},i="cabbageLoadState",c={id:"cabbage_opcodes/cabbageLoadState",title:"cabbageLoadState",description:"This opcode loads widget values from a previously saved JSON state file created by the cabbageSaveState opcode. All matching widget channels will be updated with their saved values. Unlike Cabbage 2, all widget state is saved and restored, not only the current parameter values. This opcode works at i-time only. Therefore it's best used in an instrument that is called when you want to load state.",source:"@site/docs/cabbage_opcodes/cabbageLoadState.md",sourceDirName:"cabbage_opcodes",slug:"/cabbage_opcodes/cabbageLoadState",permalink:"/cabbage3docs/docs/cabbage_opcodes/cabbageLoadState",draft:!1,unlisted:!1,editUrl:"https://github.com/rorywalsh/cabbage3docs/tree/main/docs/cabbage_opcodes/cabbageLoadState.md",tags:[],version:"current",frontMatter:{},sidebar:"docSidebar",previous:{title:"cabbageGetValue",permalink:"/cabbage3docs/docs/cabbage_opcodes/cabbageGetValue"},next:{title:"cabbageSaveState",permalink:"/cabbage3docs/docs/cabbage_opcodes/cabbageSaveState"}},d={},l=[{value:"Syntax",id:"syntax",level:2},{value:"Initialization",id:"initialization",level:3}];function r(e){const t={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"cabbageloadstate",children:"cabbageLoadState"})}),"\n",(0,s.jsxs)(t.p,{children:["This opcode loads widget values from a previously saved JSON state file created by the ",(0,s.jsx)(t.code,{children:"cabbageSaveState"})," opcode. All matching widget channels will be updated with their saved values. Unlike Cabbage 2, all widget state is saved and restored, not only the current parameter values. This opcode works at i-time only. Therefore it's best used in an instrument that is called when you want to load state."]}),"\n",(0,s.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"cabbageLoadState:i(SFilePath)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.em,{children:"SFilePath"}),' \u2013 the absolute file path to the state file to load (e.g., "/Users/username/Documents/mypreset.json" or "C:\\Users\\username\\Documents\\mypreset.json"). The file must exist and contain valid JSON data. Relative paths are not supported.']}),"\n"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Note: Only widgets with channels that match those in the saved state file will be updated. Widgets not present in the state file will retain their current values. To load different presets, use Csound's string formatting to dynamically generate filenames, for example: ",(0,s.jsx)(t.code,{children:'sprintf("/path/to/presets/preset_%d.json", iPresetNumber)'})]}),"\n"]})]})}function b(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>c});var s=a(6540);const n={},o=s.createContext(n);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);