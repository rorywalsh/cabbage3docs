"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4486],{7133:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>b});var a=t(4848),s=t(8453);const i={title:"Running Cabbage",description:"Running the Cabbage server"},r=void 0,o={id:"using_cabbage/running_cabbage",title:"Running Cabbage",description:"Running the Cabbage server",source:"@site/docs/using_cabbage/running_cabbage.md",sourceDirName:"using_cabbage",slug:"/using_cabbage/running_cabbage",permalink:"/cabbage3docs/docs/using_cabbage/running_cabbage",draft:!1,unlisted:!1,editUrl:"https://github.com/rorywalsh/cabbage3docs/tree/main/docs/using_cabbage/running_cabbage.md",tags:[],version:"current",frontMatter:{title:"Running Cabbage",description:"Running the Cabbage server"},sidebar:"docSidebar",previous:{title:"Overview",permalink:"/cabbage3docs/docs/using_cabbage/overview"},next:{title:"Working with Instruments",permalink:"/cabbage3docs/docs/using_cabbage/working_with_instruments"}},c={},b=[];function u(e){const n={code:"code",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"The Cabbage VS\u202fCode extension includes a background service that acts as a server for Cabbage\u202f3 instruments and effects within the IDE. After you install the extension, a Run\xa0Cabbage icon appears in the lower\u2011right corner of the VS\u202fCode status bar. Clicking it starts the background service and sets up a communication protocal between Cabbage and VS\u202fCode."}),"\n",(0,a.jsxs)(n.p,{children:["Whenever you save a\xa0.csd file while the Cabbage server is running, Cabbage parses the contents of the ",(0,a.jsx)(n.code,{children:"<Cabbage>"})," section and sends it to VS\u202fCode, which then constructs the UI accordingly. You can start or restart the server as often as needed, and it will automatically restart whenever you change the extension\u2019s settings. When running your instruments as plugins, communication between the frontend and the plugin is handled directly through a serious of callbacks. Although the means in which the back and frontend communicate differs between the VS Code extension, and the plugin interface, the user experience remains the same."]})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);