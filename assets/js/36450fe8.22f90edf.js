"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5772],{4399:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>l});var t=s(4848),a=s(8453);const i={title:"Custom User Interfaces",description:"Custom UI's"},o=void 0,d={id:"customUIs",title:"Custom User Interfaces",description:"Custom UI's",source:"@site/docs/customUIs.md",sourceDirName:".",slug:"/customUIs",permalink:"/cabbage3docs/docs/customUIs",draft:!1,unlisted:!1,editUrl:"https://github.com/rorywalsh/cabbage3docs/tree/main/docs/customUIs.md",tags:[],version:"current",frontMatter:{title:"Custom User Interfaces",description:"Custom UI's"},sidebar:"docSidebar",previous:{title:"XY Pad",permalink:"/cabbage3docs/docs/cabbage_widgets/xyPad"},next:{title:"Introduction",permalink:"/cabbage3docs/docs/cabbage_opcodes/intro"}},r={},l=[{value:"<strong>Custom Widget Classes</strong>",id:"custom-widget-classes",level:2},{value:"<strong>Entirely new web-based interfaces</strong>",id:"entirely-new-web-based-interfaces",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Cabbage 3 includes a variety of standard plugin controls such as sliders and buttons. However, it also provides straightforward options for creating your own custom elements. There are two primary methods for building custom UIs:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h2,{id:"custom-widget-classes",children:(0,t.jsx)(n.strong,{children:"Custom Widget Classes"})}),"\n",(0,t.jsx)(n.p,{children:"Create new widget classes and add them to Cabbage. This approach allows you to develop custom widgets while retaining the convenience of the editing tools available in the Cabbage VS Code extension. To achieve this, follow these steps:"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Steps to Create a New Widget Class"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Create a New Widget Class"}),"(): Use an existing widget class as a template. Below are key members you\u2019ll need to define:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"this.props"})}),":\nThis JSON object contains properties accessible through the UI element inspectors in VS Code. Any property defined here can also be queried and modified using the Cabbage get and set opcodes in Csound. At a minimum, this must include:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"An 'id' property"}),"\n",(0,t.jsx)(n.li,{children:"A channels array"}),"\n",(0,t.jsx)(n.li,{children:"An automatable property"}),"\n",(0,t.jsx)(n.li,{children:"A bounds object to define dimensions and placement"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Add Event Listener Methods:\nImplement two methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"addVsCodeEventListeners(widgetDiv, vs)"})}),": Called when Cabbage is running from VS Code."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"addVsCodeEventListeners()"})}),": Called when Cabbage is running as a plugin."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Both methods need to be implemented to ensure compatibility with different environments."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Define a ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"getInnerHTML()"})})," method. This method should return the inner HTML used to render the UI element. The element\u2019s size is determined by its bounds object. You can return an svg element or another div element, depending on your design needs."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Add class to the Cabbage ",(0,t.jsx)(n.code,{children:"src/cabbage/widgets"})," directory. This is installed with the VS Code extension. On MacOS it can be found here in ",(0,t.jsx)(n.code,{children:"~/.vscode/extensions"}),", and on Windows it can be found in ",(0,t.jsx)(n.code,{children:"%USERPROFILE%\\.vscode\\extensions"}),", where ",(0,t.jsx)(n.code,{children:"%USERPROFILE%"})," is typically ",(0,t.jsx)(n.code,{children:"C:\\Users\\your-username"}),". When in place, both the VS Code extension and the Cabbage service app will be able to access them. These source files get copied whenever Cabbage export a new plugin."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h2,{id:"entirely-new-web-based-interfaces",children:(0,t.jsx)(n.strong,{children:"Entirely new web-based interfaces"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can design an entirely new web-based interface using any framework you prefer. To ensure communication with the Csound/Cabbage plugin, you need to include the ",(0,t.jsx)(n.code,{children:"cabbage.js"})," file, which provides basic functions to send data to Csound from the web UI. While this method does not give access to the UI editing tools in Cabbage, it offers maximum flexibility to create custom interfaces tailored to your needs."]}),"\n",(0,t.jsxs)(n.p,{children:["To communicate with Csound, you will need to implement event handlers for sending and receiving data. The following example demonstrates a complete setup that communicates to two parameters, with ",(0,t.jsx)(n.code,{children:"id"}),"s ",(0,t.jsx)(n.code,{children:"slider1"})," and ",(0,t.jsx)(n.code,{children:"slider2"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script type=\"module\">\n    /* Cabbage JS API integration */\n    import { Cabbage } from './cabbage/cabbage.js';\n    /* Notify Cabbage that the UI is ready to load */\n    Cabbage.sendCustomCommand('cabbageIsReadyToLoad', null);\n\n    // Make handleValueChange available globally\n    window.handleValueChange = (newValue, sliderId) => {\n        console.log(`Slider ${sliderId} changed to:`, newValue);\n        const msg = {\n            paramIdx: sliderId === 'slider1' ? 0 : 1,\n            channel: sliderId,\n            value: parseFloat(newValue),\n        };\n        const automatable = 1;\n        Cabbage.sendChannelUpdate(msg, null, automatable);\n    };\n\n    const handleMessage = async (event) => {\n        console.log(\"Message received:\", event.data);\n        let obj = event.data;\n\n        let slider;\n        if (obj.command === \"parameterChange\") {\n            // For parameterChange messages, find slider by paramIdx\n            slider = obj.paramIdx === 0 ? document.getElementById('slider1') : document.getElementById('slider2');\n        } else {\n            // For other messages, find slider by id\n            slider = document.getElementById(obj.id);\n        }\n\n        if (slider) {\n            switch (obj.command) {\n                case \"parameterChange\":\n                    console.log(`Parameter change for ${obj.paramIdx}:`, obj);\n                    slider.value = obj.value;\n                    break;\n                case \"widgetUpdate\":\n                    if (obj.value !== undefined) {\n                        console.log(`Updating ${obj.id} to value:`, obj.value);\n                        slider.value = obj.value;\n                    }\n                    else if (obj.widgetJson !== undefined) {\n                        let widgetObj = JSON.parse(obj.widgetJson);\n                        let bounds = widgetObj.bounds;\n                        if (bounds) {\n                            slider.style.position = 'absolute';\n                            slider.style.top = bounds.top + 'px';\n                        }\n                        // Set value if the UI has just been reopened\n                        if (widgetObj.value !== undefined) {\n                            slider.value = widgetObj.value;\n                        }\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n\n    // Add event listener\n    window.addEventListener(\"message\", handleMessage);\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The script starts by sending a ",(0,t.jsx)(n.code,{children:"cabbageIsReadyToLoad"})," message. This is essential because it informs Cabbage that the web interface is fully loaded and ready to start exchanging data. Without this step, the plugin might miss updates or fail to synchronise with the custom UI."]}),"\n",(0,t.jsxs)(n.p,{children:["User interactions, like moving a slider or changing a control, are captured by the global function ",(0,t.jsx)(n.code,{children:"handleValueChange"}),". This function packages the new value and the associated channel information into a message that Cabbage can understand. The script uses ",(0,t.jsx)(n.code,{children:"Cabbage.sendChannelUpdate(message, vscode, automatable)"})," to transmit this data to the audio engine in real time. If ",(0,t.jsx)(n.code,{children:"automatable"})," is set to 1, then this function will also update the host. If set to 0, the data will bypass the host and go straight to Csound. If you are creating custom widgets, but continue to use the Cabbage VS-Code extension, the ",(0,t.jsx)(n.code,{children:"vscode"})," parameter will hold a valid instance of a VS Code Webview API object. In the context of audio plugins, ",(0,t.jsx)(n.code,{children:"vscode"})," will always be null."]}),"\n",(0,t.jsxs)(n.p,{children:["The script also sets up a ",(0,t.jsx)(n.code,{children:"handleMessage"})," listener to capture messages from Csound or the DAW. Messages can be either parameter values sent from the host, or through calls to the ",(0,t.jsx)(n.code,{children:"cabbageSetValue/cabbageSet"})," opcodes. Host parameter change messages are formatted like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "command": "parameterChange",\n    "paramIdx": number,\n    "value": number\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["while value updates from Csound, though calls to ",(0,t.jsx)(n.code,{children:"cabbageSetValue"}),", are formatted like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "command": "widgetUpdate",\n    "id": string,\n    "value": value\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Messages can also contain Json data, which can modify widget properties such as visibility or styling. These arrive from calls to the ",(0,t.jsx)(n.code,{children:"cabbageSet"})," opcodes, and are structured like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "command": "widgetUpdate",\n    "id": string,\n    "widgetJson": string\n}\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"You must add dummy parameters to the Cabbage section so that the software can set up the necessary channels and plugin parameters*."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var t=s(6540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);